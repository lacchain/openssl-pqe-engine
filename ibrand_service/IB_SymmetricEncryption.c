

#include <string.h>
#include <stdlib.h>

#include <openssl/evp.h>
#include <openssl/aes.h>

#include <my_utilslib.h>

#include "RFC2898DeriveBytes.h"
#include "IB_SymmetricEncryption.h"


#define PADDING_BYTE 0x00
#define INCLUDE_KNOWN_ANSWER_TESTS

// Not needed on the client side (yet)
// uint8_t *AESEncryptBytes(...)
// {
    // Call Rfc2898DeriveBytes(key, saltSize)
    // Get Salt: keyDerivationFunction.Salt;
    // Get  Key: keyDerivationFunction.GetBytes(32);
    // Get   IV: keyDerivationFunction.GetBytes(16);
    // Encrypt payload using AES in CBC mode, PKCS7 padding, derived Key and derived IV
    // Return a concatenation of Salt and cipherText as the result
// }


int AESDecryptBytes(uint8_t *pEncryptedData, size_t cbEncryptedData, uint8_t *pSharedSecret, size_t cbSharedSecret, unsigned int saltSize, uint8_t **ppDecryptedData, size_t *pcbDecryptedData)
{
    // Get Salt: First saltSize bytes of data
    // Get cipherText: Remaining bytes of data
    // Call Rfc2898DeriveBytes(key, Salt)
    // Get  Key: keyDerivationFunction.GetBytes(32);
    // Get   IV: keyDerivationFunction.GetBytes(16);
    // Decrypt cipherText using AES in CBC mode, PKCS7 padding, derived Key and derived IV
    // Return the plainText as the result

    const unsigned int derivedIVSizeInBytes = 16;

    int retval = 0;
    uint8_t *pSalt = NULL;
    size_t cbSalt = 0;
    uint8_t *pCipherText = NULL;
    size_t cbCipherText = 0;
    tRfc2898DeriveBytes *pPBKDF = NULL;
    int aes_KeySizeInBits = 0;
    uint8_t *pKey = NULL;
    uint8_t *pIV = NULL;
    uint8_t *pRawData = NULL;

    if (pcbDecryptedData)
        *pcbDecryptedData = 0;

    if (ppDecryptedData)
        *ppDecryptedData = NULL;

    //app_tracef("INFO: SRNG Decrypting %d bytes",cbEncryptedData);
    //app_tracef("INFO: [SRNGDecrypt] cbEncryptedData=%d",cbEncryptedData);
    //app_tracef("INFO: [SRNGDecrypt] cbSharedSecret  =%d",cbSharedSecret);
    //app_tracef("INFO: [SRNGDecrypt] saltSize        =%d",saltSize);

    //app_trace_hexall("DEC: EncryptedData", pEncryptedData, cbEncryptedData);
    //app_trace_hexall("DEC: SharedSecret", pSharedSecret, cbSharedSecret);

    // The salt is generated by the IB API and prefixed to the response. It's size is fixed, and well known.
    //app_tracef("DEC: saltSize = %d", saltSize);
    pSalt = malloc(saltSize);
    if (!pSalt)
    {
        app_tracef("ERROR: malloc of pSalt failed");
        retval = 999;
        goto CLEANUP_AND_RETURN;
    }
    memcpy(pSalt, pEncryptedData, saltSize);
    cbSalt = saltSize;
    //app_trace_hexall("DEC: Salt", pSalt, cbSalt);

    // The ciphertext follows the salt in the response buffer
    pCipherText = malloc(cbEncryptedData-saltSize);
    if (!pCipherText)
    {
        app_tracef("ERROR: malloc of pCipherText failed");
        retval = 999;
        goto CLEANUP_AND_RETURN;
    }
    memcpy(pCipherText, pEncryptedData+saltSize, cbEncryptedData-saltSize);
    cbCipherText = cbEncryptedData-saltSize;
    //app_trace_hexall("DEC: CipherText", pCipherText, cbCipherText);

    // Create a key from the password and salt. We use SHA-1 and 317771 (was 1000) iterations.
    // TODO: Parameterise these parameters
    // TODO: Th SharedSecret might need to be converted to UTF8
    pPBKDF = Rfc2898DeriveBytes_Init(pSharedSecret, cbSharedSecret, pSalt, cbSalt);
    if (!pPBKDF)
    {
        app_tracef("ERROR: Rfc2898DeriveBytes_Init failed");
        retval = 999;
        goto CLEANUP_AND_RETURN;
    }

    aes_KeySizeInBits = 256;
    pKey     = Rfc2898DeriveBytes_GetBytes ( pPBKDF, aes_KeySizeInBits/8   );
    if (!pKey)
    {
        app_tracef("ERROR: Rfc2898DeriveBytes_GetBytes failed");
        retval = 999;
        goto CLEANUP_AND_RETURN;
    }
    //app_trace_hexall("DEC: pKey", pKey, derivedKeySizeInBytes);

    pIV      = Rfc2898DeriveBytes_GetBytes ( pPBKDF, derivedIVSizeInBytes ); //AES_BLOCK_SIZE ); // uint8_t iv[AES_BLOCK_SIZE];
    if (!pIV)
    {
        app_tracef("ERROR: Rfc2898DeriveBytes_GetBytes failed");
        retval = 999;
        goto CLEANUP_AND_RETURN;
    }
    //app_trace_hexall("DEC: pIV", pIV, derivedIVSizeInBytes);

    ///////////////////////////////////
    // Decrypt the data...
    ///////////////////////////////////
    AES_KEY opensslAesKey;
    int rc;

    rc = AES_set_decrypt_key((uint8_t *)pKey, aes_KeySizeInBits, &opensslAesKey); // Size of key is in bits
    // AES_set_encrypt_key() and AES_set_decrypt_key() return 0 for success, -1 if userKey or key is NULL, or -2 if the number of bits is unsupported.
    if (rc != 0)
    {
        app_tracef("ERROR: AES_set_decrypt_key failed with rc=%d", rc);
        retval = 997;
        goto CLEANUP_AND_RETURN;
    }
    //app_tracef("INFO: Decrypting %u bytes", pIBRand->symmetricSessionKey.cbData);
    pRawData = (uint8_t *)malloc(cbCipherText);
    if (!pRawData)
    {
        app_tracef("ERROR: Malloc of pRawData failed");
        retval = 997;
        goto CLEANUP_AND_RETURN;
    }
    AES_cbc_encrypt(pCipherText, pRawData, cbCipherText, &opensslAesKey, (unsigned char *)pIV, AES_DECRYPT);

    if (ppDecryptedData && pcbDecryptedData)
    {
        *ppDecryptedData = pRawData;  // Returns a malloc'd buffer. It is the responsibility of the caller to free this when no longer needed
        *pcbDecryptedData = cbCipherText;
    }

    retval = 0;

CLEANUP_AND_RETURN:
    if (pIV        ) free(pIV);
    if (pKey       ) free(pKey);
    if (pPBKDF     ) free(pPBKDF);
    if (pCipherText) free(pCipherText);
    if (pSalt      ) free(pSalt);

    return retval;
}

int ispadding(unsigned int cbData1, unsigned int cbData2, unsigned int N, unsigned char *pData1)
{
    if ((cbData1-cbData2) > 0 && (cbData1-cbData2) <= N)
    {
        unsigned int paddinglen = cbData1-cbData2;
        int is_pkcs7_padding = true;

        for (unsigned int ii=0;ii<paddinglen;ii++)
        {
            if (pData1[cbData2+ii] != paddinglen)
            {
                is_pkcs7_padding = false;
                break;
            }
        }
        return is_pkcs7_padding;
        // Typically...
        //if (is_pkcs7_padding)
        //    cbData1 = cbData2;
    }
    return false;
}

#ifdef INCLUDE_KNOWN_ANSWER_TESTS
int testSymmetricEncryption(void)
{
    OUTPUT_TO_CONSOLE_ENABLED = 1;
    int failed_tests = 0;
    bool rc;
    int testno = 1;
    app_tracef("=============================================== TEST %d", testno++);

    ///////////////////////////////////////////
    // Dummy Data
    ///////////////////////////////////////////

    uint8_t *pSessionKey;
    size_t cbSessionKey = 0;
    uint8_t *pEncryptedData = NULL;
    size_t cbEncryptedData = 0;
    uint8_t *pDecryptedData = NULL;
    size_t cbDecryptedData = 0;
    int saltSize = 32;

    fprintf(stderr, "==================================== Decrypt Dummy Data\n");
    pSessionKey = malloc(16);
    if (pSessionKey == NULL)
    {
        fprintf(stderr, "pSessionKey == NULL\n");
        return -1;
    }
    cbSessionKey = 16;
    memset(pSessionKey, 0xAA, cbSessionKey);

    pEncryptedData = malloc(1000);
    if (pEncryptedData == NULL)
    {
        fprintf(stderr, "pEncryptedData == NULL\n");
        free(pSessionKey);
        return -1;
    }
    cbEncryptedData = 1000;
    memset(pEncryptedData, 0x55, cbEncryptedData);

    //dumpToFile("/home/jgilmore/dev/dump_test1_A_encrypted_data.txt", pEncryptedData, cbEncryptedData);
    rc = AESDecryptBytes(pEncryptedData, cbEncryptedData, pSessionKey, cbSessionKey, saltSize, &pDecryptedData, &cbDecryptedData);
    //dumpToFile("/home/jgilmore/dev/dump_test1_B_decrypted_data.txt", pRawData, cbRawData);
    if (rc != 0)
    {
        fprintf(stderr, "AESDecryptBytes failed with rc=%d\n", rc);
        free(pEncryptedData);
        free(pSessionKey);
        return -1;
    }

    free(pDecryptedData);
    free(pEncryptedData);
    free(pSessionKey);

    app_tracef("=============================================== TEST %d", testno++);
    ///////////////////////////////////////////
    // IronBridge Data
    ///////////////////////////////////////////
    fprintf(stderr, "==================================== Decrypt Sample IronBridge Data BEGIN\n");

    char *pIronBridgeSessionKeyB64 = "bCgEPw9fFD8/Pz8APz8BCQ==";
    size_t cbIronBridgeSessionKeyB64 = strlen(pIronBridgeSessionKeyB64);
    char *pIronBridgeOriginalDataB64 = "mk9oRgr1pDi8jsplMMu5njFbPbV1kpUEcbV1EaU4lvhFjlgHdcEm2nJGPdUEGMe9QMnfWudtyAwgf4cnZztaEga4ZItfEr9FBwhZnpayvL88l7RMACkv1EX7TM4fKj9TsfvJpv8jaDPgbJOJ4vcvtD5nJcbAADLPKIs0eitaFNiH2gR6x02WZK6JvEf3oRUG7c6FxgS4lhZ0cCTESfNsIy7ySnCY2cgTLoX1XxjbER5ERmyn3sBvkGNl3Jw866nCJ6ZrL9yqd2iLpIB4DZLPT+IjDoVzaLApu04zTxq9BOaOn2/IjmRaEE8/BSAB4LKHytVoX5dVws8SekgkVTuS6g==";
    size_t cbIronBridgeOriginalDataB64 = strlen(pIronBridgeOriginalDataB64);
    char *pTransmittedDataB64 = "CnTVLRVauZfdNRrJY2Kqx611PyANEd1sh6jsZvVbnB6hb87LOOk5yBIDmdvCTNQcRJUARF3WNkWl7QyMQwGOAEVg/JFfOh1yTGcMNZ7VAUtQy/54X6zd7KyXMC9pE6HQElC9CCe9qVxfsd10ZYkiPE3bicIfQ68bvvf6b/TMXYnGJniIgDC3n9jUhlWG2NJEkeI+J1GCkYoVDGPT0p20sQ6YHMz+kkIsVIkaWk6146C6vLRWvngUL348nILsG71N5kRO00L42WDb1VSsCs2sutrRbyOiRK7vDWg+VC/cLRKsV8sa5/3X39CgJ6+e+pX9AftrDIhwLW8R5CONBXJoiifw6ugTt56zLqUQT5T05lBE7Q9AXQxwsa6MbQP3viBn";
    size_t cbTransmittedDataB64 = strlen(pTransmittedDataB64);

    size_t cbIronBridgeSessionKey = 0;
    unsigned char *pIronBridgeSessionKey = base64_decode(pIronBridgeSessionKeyB64, cbIronBridgeSessionKeyB64, &cbIronBridgeSessionKey);
    size_t cbIronBridgeOriginalData = 0;
    unsigned char *pIronBridgeOriginalData = base64_decode(pIronBridgeOriginalDataB64, cbIronBridgeOriginalDataB64, &cbIronBridgeOriginalData);
    size_t cbTransmittedData = 0;
    unsigned char *pTransmittedData = base64_decode(pTransmittedDataB64, cbTransmittedDataB64, &cbTransmittedData);

    //dumpToFile("/home/jgilmore/dev/dump_test1_A_encrypted_data.txt", pEncryptedData, cbEncryptedData);
    rc = AESDecryptBytes(pTransmittedData, cbTransmittedData, pIronBridgeSessionKey, cbIronBridgeSessionKey, 16, &pDecryptedData, &cbDecryptedData);
    if (rc)
    {
        fprintf(stderr, "AESDecryptBytes failed with rc=%d\n", rc);
    }
    //dumpToFile("/home/jgilmore/dev/dump_test1_B_decrypted_data.txt", pRawData, cbRawData);

    if (ispadding(cbDecryptedData, cbIronBridgeOriginalData, 16, pDecryptedData))
    {
        cbDecryptedData = cbIronBridgeOriginalData;
    }
    if (ispadding(cbIronBridgeOriginalData, cbDecryptedData, 16, pIronBridgeOriginalData))
    {
        cbIronBridgeOriginalData = cbDecryptedData;
    }

    if ((cbDecryptedData != cbIronBridgeOriginalData) || (memcmp(pDecryptedData,pIronBridgeOriginalData,cbIronBridgeOriginalData) != 0))
    {
        fprintf(stderr, "Data Compare Failed\n");
        app_trace_hexall("pIronBridgeOriginalData", pIronBridgeOriginalData, cbIronBridgeOriginalData);
        app_trace_hexall("pDecryptedData         ", pDecryptedData, cbDecryptedData);
    }
    else
    {
        fprintf(stderr, "Data Compare OK\n");
    }
    free(pIronBridgeSessionKey);
    free(pIronBridgeOriginalData);
    free(pTransmittedData);
    fprintf(stderr, "==================================== Decrypt Sample IronBridge Data END\n");

    app_tracef("=============================================== DONE");

    return failed_tests;
}

#endif // INCLUDE_KNOWN_ANSWER_TESTS
